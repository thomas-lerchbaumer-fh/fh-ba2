%----------------------------------------------------------------
%
%  File    :  analytical_dashboard.tex
%
%  Authors : Thomas Lerchbaumer
% 
%  Created :  19 March 2022
% 
%  Changed :  19 March
% 
%----------------------------------------------------------------

\chapter{Implementation of Averages and Grouping}
\label{chap:analytical_dashboard}
This section focuses on the implementation of various groupings as well as their visualization. As the analytical dashboard is web based a short overview about its technical setup is given in section \ref{sec:tech_set}.

\section{Technical Setup}
\label{sec:tech_set}
As those implementations will contribute to an analytical dashboard the visualization of the prepared data are implemented using React. For each grouping a separate React component is created. Communication between the front- and backend is accomplished using a Rest interface. 

\begin{itemize}
\item  \verb|React|\footnote{https://react.dev/} - used to Visualize
\item \verb|Python|\footnote{https://www.python.org/} - used to implement the grouping logic
\item \verb|fastapi|\footnote{https://fastapi.tiangolo.com/} - Rest interface (Connection between Backend and Frontend) 
\item \verb|geopy|\footnote{https://geopy.readthedocs.io/en/stable/} - Used for calculations on latitude and longitude 
\end{itemize}


\section{Grouping Implementation}

\subsection{Grouping by Geographical Attributes}
The dataset for bus search requests (after cleaning) currently got around 230.000 entries. As the geographical calculations as well as the grouping logic are computational expensive tasks it is not feasible to redo this logic on every request. To enable real time requests with various filters onto the grouped data an additional database table. The table consists of two attributes: 
\begin{itemize}
\item \verb|parent_id (FK - search_requests(task_id)| - parent that defines a region 
\item \verb|child_id (FK - search_requests(task_id)| - entries that belong to a certain parent region  
\end{itemize}
This design comes along with several advantages. The logic for analytical requests and the grouping logic can be separated. Furthermore new entries for groupings can be added to a potential parent in a more efficient way as those entries only need to be compared to the attributes of \verb|parent_id|.

For geographical grouping the following logic is applied:
\begin{lstlisting}
radius = 20 # in km
res = collections.defaultdict(list)
ignore_list = set()
for point_a in data:
   if point_a['id'] in ignore_list:  # Skip if point_b['id'] is in ignore_list
      continue
   tmp_point_a_dep = tuple((point_a['taskFrom_lng'], point_a['taskFrom_lat']))
   tmp_point_a_dest = tuple((point_a['taskTo_lng'], point_a['taskTo_lat']))
   for point_b in data:
	   tmp_point_b_dep = tuple((point_b['taskFrom_lng'], point_b['taskFrom_lat']))
       tmp_point_b_dest = tuple((point_b['taskTo_lng'], point_b['taskTo_lat']))
       actual_distance_dep = distance.great_circle(tmp_point_a_dep, tmp_point_b_dep).km
       actual_distance_dest = distance.great_circle(tmp_point_a_dest, tmp_point_b_dest).km
       if actual_distance_dep < radius and actual_distance_dest < radius:
          key = point_a['id']
          res[key].append(point_b)
          ignore_list.add(point_b['id'])  # Add point_b['id'] to ignore_list
\end{lstlisting}
This logic performs the comparison between two geographical entries. Whenever \verb|point\_b| is within a 20km radius of the departure and destination area from \verb|point\_a| \verb|point\_b| is added to the group from \verb|point\_a|. Utilizing this design makes it possible to still include filters like date ranges to filter groupings by date. Additional a trip is added to an ignore list to avoid micro groupings as some points might added to multiple groups. Furthermore the averages for attributes explained in section \ref{sec:averages} can be utilized and compared to evaluate certain trends. By adjusting the logic above and removing the constraint that both destination and departure has to be within a certain range this data can further be grouped into popular destination places as well as popular departure places. Depending on the grouping technique various insights can be gathered. By analysing grouped data that mark routes (same departure/destination radius) the pricing strategy for routes with high demand can be adapted. Whereas analysing the grouping on departure places with high traffic bus operators might consider to expand their maximum approaching distance. Furthermore by changing the way how the data is fetched from the database by querying results where no bus was offered \verb|amountSearchResults == 0| a different grouping becomes available for analysing. 
\subsubsection{Visualization}
Depending on how the entries are grouped different Visualization techniques are applied. To detect departure areas with high demand a heatmap is utilized. Therefore a interactive map is utilized. Onto this map areas with high demand are plotted following a color scheme. Red circles indicate high demand whereas blue areas indicate areas with less demand as shown in figure \ref{fig:heatmap_dep}. Furthermore this visualization can be filtered by applying date ranges. Additionally areas with high demand are displayed in a table including total count of requests for a certain area, average pax as well as the average travel distance.
\newline
As a heatmap is not suitable to visualize the grouped routes those groupings are displayed using a table. Additional the table is filterable by date in order to be able to analyse the data split up into certain time periods. Furthermore the table hosts information about average pax and average travel distance. 
\begin{figure}[H]
	\centering
		\includegraphics[width=15cm]{images/heatmap_dep}
	\caption{Interactive heatmap highlighting departure places with high demand - [source:[author]]}
	\label{fig:heatmap_dep}
\end{figure}


\subsection{Grouping by Time}
In contrast to geographical grouping, groupings by time do not require a table within the database in order to process requests in real time. To group requests by time the following logic is applied to the fetched data: 
\begin{lstlisting}
def group_requests_by_time(data):
    df = pd.DataFrame(data)
    df = pd.to_datetime(df[0])
    grouped = df.groupby(df.dt.hour).count()
    for name in grouped.index:
        tmp = {"x": str(name) + ":00", "y": int(grouped.loc[name])}
        res[0]['data'].append(tmp)
    return res
\end{lstlisting}
To group search requests by days the following logic is applied: 
\begin{lstlisting}
def group_requests_by_day(data):
    data_format = pd.DataFrame(data)
    data_format = pd.to_datetime(data_format[0], format='%Y-%m-%d %H:%M:%S')
    grouped = data_format.groupby([data_format.dt.year, data_format.dt.month, data_format.dt.day]).count()
    res = []
    for name in grouped.index:
        date = str(name[0]) + "-" + str(name[1]) + "-" + str(name[2])
        tmp = {"value": int(grouped.loc[name]), "day": date}
        res.append(tmp)
    res = sorted(res, key=lambda x: x['day'])
    return res
\end{lstlisting}
The information gathered from those groupings can be utilized to support the scheduling of future ad campaigns.

\subsubsection{Visualization}
The hourly groupings are visualized using a line chart as demonstrated in figure \ref{fig:hourly_grouping}.
\begin{figure}[H]
	\centering
		\includegraphics[width=15cm]{images/requests_hour}
	\caption{Requests grouped on hourly basis- [source:[author]]}
	\label{fig:hourly_grouping}
\end{figure}

\begin{figure}[H]
	\centering
		\includegraphics[width=15cm]{images/request_calendar}
	\caption{Requests grouped by date - [source:[author]]}
	\label{fig:hourly_grouping}
\end{figure}

